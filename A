#include "grader.h"
#include<iostream>
#include<vector>
#include<string>
#include <algorithm>
using namespace std;

Patient::Patient(string firstname, string lastname, int visit_time, int visit_length) {
    this->firstname=firstname;
    this->lastname=lastname;
    this->visit_time=visit_time;
    this->visit_length=visit_length;
}
string Patient::get_firstname() {
    return firstname;
}
string Patient::get_lastname() {
    return lastname;
}
int Patient::get_visit_time() {
    return visit_time;
}
int Patient::get_visit_length() {
    return visit_length;
}
void Clinic::set_maximum_patients(int maximum_patient) {
    maximum_patients=maximum_patient;
    patients.reserve(maximum_patient);
}
bool Clinic::add_patient(string firstname, string lastname, int visit_time, int visit_length) {
    if(patients.size() == maximum_patients)
        return false;
    for(auto i = patients.begin(); i != patients.end(); i++){
        if(i->get_lastname() == lastname){
            return false;
        }
    }
    for(auto i = patients.begin();i!=patients.end();i++){
        if(i->get_visit_time()*60 >= 60*visit_time+visit_length){
            continue;
        }
        else if((i->get_visit_time())*60+(i->get_visit_length())<=visit_time*60){
            continue;
        }
        else
            return false;
    }
    Patient new_person(firstname,lastname,visit_time,visit_length);
    patients.push_back(new_person);
    return true;

}

bool Clinic::remove_patient(std::string lastname) {
    for(auto i = patients.begin(); i != patients.end(); i++){
        if(i->get_lastname()==lastname){
            patients.erase(i);
            return true;
        }
    }
    return false;
}

void Clinic::checkup() {
    if(patients.size() == 0)
          return;
    vector<Patient>::iterator index;
    int min_time = patients[0].get_visit_time();
    index = patients.begin();
    for(vector<Patient>::iterator i = patients.begin(); i != patients.end(); i++){
        if(i->get_visit_time()<min_time){
            min_time=i->get_visit_time();
            index=i;
        }
    }
    patients.erase(index);

}

Patient Clinic::get_patient(int index) {
    if(index >= patients.size()){
        Patient *new_person = nullptr;
        return *new_person;
    }
    else{
        int arr[patients.size()];
        int j=0;
        for(auto i = patients.begin(); i != patients.end(); i++){
            arr[j]=i->get_visit_time();
            j++;
        }
        sort(arr,arr+j);
        for(auto k=patients.begin();k!=patients.end();k++){
            if(arr[index] == k -> get_visit_time()){
                return *k;
            }
        }
    }
}
